<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Polygon Drawer with Paint Tool</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }
    canvas {
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      background-size: cover;
      background-position: center;
    }
    ul {
      width: 800px;
      max-width: 100%;
      list-style: none;
      padding: 0;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      cursor: pointer;
    }
    .selected {
      background: #eee;
    }
    .delete-btn {
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      margin-left: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <input type="file" id="imageLoader" accept="image/*" />
  <canvas id="canvas" width="800" height="600"></canvas>
  <div>
    <input type="color" id="colorPicker" value="#0096ff" />
    <input type="text" id="labelInput" placeholder="Label" />
    <button onclick="finishPolygon()">Finish Polygon</button>
    <button onclick="undoPoint()">Undo Point</button>
    <button onclick="resetCanvas()">Reset</button>
  </div>
  <ul id="polygonList"></ul>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const colorPicker = document.getElementById("colorPicker");
    const labelInput = document.getElementById("labelInput");
    const polygonList = document.getElementById("polygonList");
    const imageLoader = document.getElementById("imageLoader");

    let polygons = [];
    let currentPoints = [];
    let selectedPolygonIndex = null;
    let backgroundImage = null;

    imageLoader.addEventListener("change", function (e) {
      const reader = new FileReader();
      reader.onload = function (event) {
        const img = new Image();
        img.onload = function () {
          backgroundImage = img;
          renderCanvas();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    });

    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const point = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      if (selectedPolygonIndex === null) {
        currentPoints.push(point);
      } else {
        const index = polygons.findIndex(p => isPointInPolygon(point, p.points));
        selectedPolygonIndex = index !== -1 ? index : null;
        renderCanvas();
      }
      renderCanvas();
    });

    function undoPoint() {
      currentPoints.pop();
      renderCanvas();
    }

    function finishPolygon() {
      if (currentPoints.length < 3) return alert("Need at least 3 points");
      polygons.push({ points: [...currentPoints], color: colorPicker.value, label: labelInput.value });
      currentPoints = [];
      labelInput.value = "";
      renderCanvas();
      renderList();
    }

    function resetCanvas() {
      polygons = [];
      currentPoints = [];
      selectedPolygonIndex = null;
      renderCanvas();
      renderList();
    }

    function isPointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
          (point.x < (xj - xi) * (point.y - yi) / ((yj - yi) || 1) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function renderCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (backgroundImage) ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      polygons.forEach((poly, index) => {
        const { points, color, label } = poly;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        points.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.5;
        ctx.fill();
        ctx.globalAlpha = 1.0;

        if (label) {
          const centroid = getCentroid(points);
          ctx.fillStyle = "black";
          ctx.font = "14px Arial";
          ctx.fillText(label, centroid.x, centroid.y);
        }
      });

      if (currentPoints.length > 0) {
        ctx.beginPath();
        ctx.moveTo(currentPoints[0].x, currentPoints[0].y);
        currentPoints.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
      }
    }

    function getCentroid(points) {
      let x = 0, y = 0;
      points.forEach(p => { x += p.x; y += p.y; });
      return { x: x / points.length, y: y / points.length };
    }

    function renderList() {
      polygonList.innerHTML = "";
      polygons.forEach((poly, index) => {
        const li = document.createElement("li");
        li.className = index === selectedPolygonIndex ? "selected" : "";
        li.innerHTML = `
          <span>${poly.label || `Polygon #${index + 1}`}</span>
          <input type="color" value="${poly.color}" onchange="updateColor(${index}, this.value)" />
          <button class="delete-btn" onclick="deletePolygon(event, ${index})">Delete</button>
        `;
        li.onclick = () => {
          selectedPolygonIndex = index;
          colorPicker.value = poly.color;
          renderCanvas();
          renderList();
        };
        polygonList.appendChild(li);
      });
    }

    function updateColor(index, color) {
      polygons[index].color = color;
      renderCanvas();
      renderList();
    }

    function deletePolygon(event, index) {
      event.stopPropagation();
      polygons.splice(index, 1);
      if (selectedPolygonIndex === index) selectedPolygonIndex = null;
      else if (selectedPolygonIndex > index) selectedPolygonIndex--;
      renderCanvas();
      renderList();
    }

    // Flood fill function
    function floodFill(x, y, targetColor, fillColor) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = imageData.data;
      const stack = [{ x, y }];
      const targetColorRgb = hexToRgb(targetColor);
      const fillColorRgb = hexToRgb(fillColor);

      function hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
      }

      function getPixel(x, y) {
        const index = (y * canvas.width + x) * 4;
        return {
          r: pixels[index],
          g: pixels[index + 1],
          b: pixels[index + 2]
        };
      }

      function setPixel(x, y, color) {
        const index = (y * canvas.width + x) * 4;
        pixels[index] = color.r;
        pixels[index + 1] = color.g;
        pixels[index + 2] = color.b;
        pixels[index + 3] = 255; // full opacity
      }

      function colorDistance(color1, color2) {
        const r = color1.r - color2.r;
        const g = color1.g - color2.g;
        const b = color1.b - color2.b;
        return Math.sqrt(r * r + g * g + b * b);
      }

      // Flood fill algorithm
      while (stack.length > 0) {
        const { x, y } = stack.pop();
        const pixelColor = getPixel(x, y);

        if (colorDistance(pixelColor, targetColorRgb) < 50) {
          setPixel(x, y, fillColorRgb);

          if (x > 0) stack.push({ x: x - 1, y });
          if (x < canvas.width - 1) stack.push({ x: x + 1, y });
          if (y > 0) stack.push({ x, y: y - 1 });
          if (y < canvas.height - 1) stack.push({ x, y: y + 1 });
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    // Paint tool click to change wall color
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const point = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      const targetColor = getPixelColor(point.x, point.y);
      const fillColor = colorPicker.value;
      floodFill(point.x, point.y, targetColor, fillColor);
    });

    function getPixelColor(x, y) {
      const pixel = ctx.getImageData(x, y, 1, 1);
      return `rgb(${pixel.data[0]},${pixel.data[1]},${pixel.data[2]})`;
    }
  </script>
</body>
</html>
